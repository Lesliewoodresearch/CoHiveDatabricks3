/**
 * Databricks OAuth Authentication
 * Handles OAuth 2.0 flow with Databricks for secure authentication
 */

interface DatabricksOAuthConfig {
  clientId: string;
  redirectUri: string;
  scopes: string[];
}

interface DatabricksTokenResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  refresh_token?: string;
  scope: string;
}

interface DatabricksSession {
  accessToken: string;
  refreshToken?: string;
  expiresAt: number;
  workspaceHost: string;
}

const OAUTH_CONFIG: DatabricksOAuthConfig = {
  clientId: (typeof import.meta.env !== 'undefined' && import.meta.env.VITE_DATABRICKS_CLIENT_ID) || '',
  redirectUri: (typeof import.meta.env !== 'undefined' && import.meta.env.VITE_DATABRICKS_REDIRECT_URI) || (typeof window !== 'undefined' ? `${window.location.origin}/oauth/callback` : ''),
  scopes: ['all-apis', 'offline_access'], // offline_access for refresh token
};

const SESSION_KEY = 'cohive_databricks_session';

/**
 * Generate OAuth authorization URL
 */
export function getAuthorizationUrl(workspaceHost: string): string {
  const state = generateRandomState();
  sessionStorage.setItem('oauth_state', state);
  sessionStorage.setItem('oauth_workspace_host', workspaceHost);

  const params = new URLSearchParams({
    client_id: OAUTH_CONFIG.clientId,
    response_type: 'code',
    redirect_uri: OAUTH_CONFIG.redirectUri,
    scope: OAUTH_CONFIG.scopes.join(' '),
    state: state,
  });

  return `https://${workspaceHost}/oidc/v1/authorize?${params.toString()}`;
}

/**
 * Exchange authorization code for access token
 */
export async function exchangeCodeForToken(
  code: string,
  workspaceHost: string
): Promise<DatabricksSession> {
  try {
    const response = await fetch(`https://${workspaceHost}/oidc/v1/token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code: code,
        redirect_uri: OAUTH_CONFIG.redirectUri,
        client_id: OAUTH_CONFIG.clientId,
      }),
    }).catch(err => {
      console.error('Network error during token exchange:', err);
      throw new Error('Unable to connect to Databricks. Please check your network connection.');
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      console.error('Token exchange failed:', response.status, errorText);
      throw new Error('Failed to exchange authorization code for token');
    }

    const tokenData: DatabricksTokenResponse = await response.json();

    const session: DatabricksSession = {
      accessToken: tokenData.access_token,
      refreshToken: tokenData.refresh_token,
      expiresAt: Date.now() + tokenData.expires_in * 1000,
      workspaceHost,
    };

    // Store session
    saveSession(session);

    return session;
  } catch (error) {
    console.error('Failed to exchange code for token:', error);
    throw error;
  }
}

/**
 * Refresh access token using refresh token
 */
export async function refreshAccessToken(): Promise<DatabricksSession | null> {
  const session = getSession();
  
  if (!session?.refreshToken) {
    return null;
  }

  try {
    const response = await fetch(`https://${session.workspaceHost}/oidc/v1/token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: session.refreshToken,
        client_id: OAUTH_CONFIG.clientId,
      }),
    }).catch(err => {
      console.error('Network error during token refresh:', err);
      return null;
    });

    if (!response || !response.ok) {
      console.error('Token refresh failed:', response?.status);
      clearSession();
      return null;
    }

    const tokenData: DatabricksTokenResponse = await response.json();

    const newSession: DatabricksSession = {
      accessToken: tokenData.access_token,
      refreshToken: tokenData.refresh_token || session.refreshToken,
      expiresAt: Date.now() + tokenData.expires_in * 1000,
      workspaceHost: session.workspaceHost,
    };

    saveSession(newSession);
    return newSession;
  } catch (error) {
    console.error('Failed to refresh token:', error);
    clearSession();
    return null;
  }
}

/**
 * Get current valid session (refreshing if needed)
 */
export async function getValidSession(): Promise<DatabricksSession | null> {
  try {
    const session = getSession();

    if (!session) {
      return null;
    }

    // Check if token is expired or will expire in next 5 minutes
    const expiresIn = session.expiresAt - Date.now();
    const needsRefresh = expiresIn < 5 * 60 * 1000;

    if (needsRefresh && session.refreshToken) {
      return await refreshAccessToken();
    }

    return session;
  } catch (error) {
    console.error('Error getting valid session:', error);
    return null;
  }
}

/**
 * Get stored session
 */
export function getSession(): DatabricksSession | null {
  try {
    const stored = sessionStorage.getItem(SESSION_KEY);
    if (stored) {
      return JSON.parse(stored);
    }
  } catch (error) {
    console.error('Failed to load session:', error);
  }
  return null;
}

/**
 * Save session
 */
function saveSession(session: DatabricksSession): void {
  try {
    sessionStorage.setItem(SESSION_KEY, JSON.stringify(session));
  } catch (error) {
    console.error('Failed to save session:', error);
  }
}

/**
 * Clear session
 */
export function clearSession(): void {
  sessionStorage.removeItem(SESSION_KEY);
  sessionStorage.removeItem('oauth_state');
  sessionStorage.removeItem('oauth_workspace_host');
  sessionStorage.removeItem('oauth_return_step');
}

/**
 * Check if URL has OAuth callback parameters
 */
export function hasOAuthCallback(): boolean {
  if (typeof window === 'undefined') return false;
  const params = new URLSearchParams(window.location.search);
  return !!(params.get('code') && params.get('state'));
}

/**
 * Check if user is authenticated
 */
export function isAuthenticated(): boolean {
  const session = getSession();
  return !!(session && session.expiresAt > Date.now());
}

/**
 * Initiate OAuth login flow
 */
export function initiateLogin(workspaceHost: string, returnToStep?: string): void {
  // Store the current step to return to after OAuth
  if (returnToStep) {
    sessionStorage.setItem('oauth_return_step', returnToStep);
  }
  
  const authUrl = getAuthorizationUrl(workspaceHost);
  window.location.href = authUrl;
}

/**
 * Handle OAuth callback
 */
export async function handleOAuthCallback(): Promise<DatabricksSession | null> {
  const params = new URLSearchParams(window.location.search);
  const code = params.get('code');
  const state = params.get('state');
  const error = params.get('error');

  if (error) {
    throw new Error(`OAuth error: ${error}`);
  }

  const storedState = sessionStorage.getItem('oauth_state');
  const workspaceHost = sessionStorage.getItem('oauth_workspace_host');

  if (!code || !state || !storedState || !workspaceHost) {
    throw new Error('Invalid OAuth callback');
  }

  if (state !== storedState) {
    throw new Error('OAuth state mismatch');
  }

  // Exchange code for token
  const session = await exchangeCodeForToken(code, workspaceHost);

  // Clean up
  sessionStorage.removeItem('oauth_state');
  sessionStorage.removeItem('oauth_workspace_host');

  return session;
}

/**
 * Logout user
 */
export function logout(): void {
  clearSession();
  window.location.href = '/';
}

/**
 * Generate random state for OAuth
 */
function generateRandomState(): string {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}

/**
 * Get workspace host from session
 */
export function getWorkspaceHost(): string | null {
  const session = getSession();
  return session?.workspaceHost || null;
}
